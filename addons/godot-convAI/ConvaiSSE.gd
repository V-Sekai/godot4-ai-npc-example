extends Node
## This is a script to query ConvAI for AI-generated NPC dialogue using convai's stream protocal and server-sent-events.  
## You need a ConvAI API key for this to work; put it as a string in the
## export variable for api_key and in the ready script for Godot-AI-NPC Controller
## (if using the demo scene).

# Signal used to alert other entities of the final convAI response text
signal AI_response_generated(response)

# Signal used to alert other entities that voice sample was played
signal convAI_voice_sample_played

# Signal used to alert other entities that action was reported
signal AI_action_generated(action)

# Choose whether to use action generation endpoint or normal one
@export var use_action_response_endpoint : bool = true

# Input or load API Key
@export var api_key : String = "insert_your_convai_API_key": set = set_api_key

# Convai Character ID from dashboard
@export var convai_character_id : String = "f2b59698-1352-11ee-bb1a-42010a400002"

# Special client node for receiving server sent events
@onready var http_sse_client = $ConvaiHTTPSSEClient

# Choose whether to receive voice responses from Convai
@export var voice_response : bool = true

# Sample rate for voice generated by Convai
@export var voice_sample_rate: int = 22050 #Has to be 44100 for "high quality" Convai voices and 22050 for regular voices

# Could use this to try to control pitch of Convai voice; not used
@export var voice_pitch_scale = 1.0

# Convai endpoint
var url : String = "https://api.convai.com"
var sub_url : String = "/character/getActionResponse"

# Convai session ID - -1 is a reset, otherwise can continue session
var convai_session_id = "-1": get = get_session_id, set = set_session_id

# Other variables for generating / queuing audio
var voice_response_string : String
var headers : PackedStringArray
var stored_streamed_audio : PackedByteArray = []
var stream_queued_text : String = ""
var convai_speech_player : AudioStreamPlayer
var convai_stream : AudioStreamWAV

# Array of actions pre-defined for convai character if using actions endpoint
var actions = "follow, jump, stay here"
	
func _ready():
	# If using endpoint without actions, switch sub_url
	if use_action_response_endpoint == false:
		sub_url = "/character/getResponse"
	# Connect signals with child SSEClient node
	http_sse_client.connect("connected", Callable(self, "on_connected"))
	http_sse_client.connect("audio_received", Callable(self, "_on_audio_received"))
	http_sse_client.connect("text_received", Callable(self, "_on_text_received"))
	http_sse_client.connect("sessionID_received", Callable(self,"_on_sessionID_received"))
	http_sse_client.connect("tag_received", Callable(self, "_on_tag_received"))
	http_sse_client.connect("action_sequence_received", Callable(self, "_on_action_received"))
	# Try to start the connection to Convai to reduce response times once a request is made
	http_sse_client.domain = url
	http_sse_client.port = -1
	http_sse_client.attempt_to_connect()
	
	set_api_key(api_key)
	set_session_id(convai_session_id)
	set_character_id(convai_character_id)
	set_voice_response_mode(voice_response)
	
	# Create audio player node for speech playback
	convai_speech_player = AudioStreamPlayer.new()
	convai_speech_player.pitch_scale = voice_pitch_scale
	convai_speech_player.connect("finished", Callable(self, "_on_speech_player_finished"))
	add_child(convai_speech_player)
	convai_stream = AudioStreamWAV.new()
	convai_stream.loop_mode = AudioStreamWAV.LOOP_DISABLED
	convai_stream.format = AudioStreamWAV.FORMAT_16_BITS
	convai_stream.mix_rate = voice_sample_rate
	
	# Testing only
#	await get_tree().create_timer(10.0).timeout
#	call_convai_SSE("Hi there!")
#	await get_tree().create_timer(25.0).timeout
#	call_convai_SSE("Jump now!")
#
func call_convai_SSE(prompt : String):
	var headers = PackedStringArray(["CONVAI-API-KEY: " + api_key, "Content-Type: application/x-www-form-urlencoded"])
	if voice_response == true:
		voice_response_string = "True"
	else:
		voice_response_string = "False"
			
	print("calling convAI_SSE with prompt:" + prompt)
	var body = {
		"userText": prompt,
		"charID": convai_character_id,
		"sessionID": convai_session_id,
		"voiceResponse": voice_response_string,
		"actions": actions,
		"stream": "True"
	}
	
	var form_data = http_sse_client.httpclient.query_string_from_dict(body)
	print(form_data)
	
	# Now call convAI, using this method will catch if for some reason there is not a present connection to reinitate it as well as make a request
	http_sse_client.connect_to_host(url, sub_url, 443, true, false, headers, form_data)

func on_connected():
	pass 

func _on_text_received(new_text : String):
	if !new_text.begins_with("*") and !new_text.ends_with("*"):
		emit_signal("AI_response_generated", new_text)
	
func _on_audio_received(new_audio_data):
	var encoded_audio = Marshalls.base64_to_raw(new_audio_data)
	# Try to eliminate pops in audio
	for n in 60:
		encoded_audio.remove_at(0)
	encoded_audio.resize(encoded_audio.size()-80)
	stored_streamed_audio.append_array(encoded_audio)
	# If speech player not playing, play streamed audio and delete the queue if any; if audio is currently playing just queue audio for delivery after
	if !convai_speech_player.playing:
		convai_stream.data = stored_streamed_audio
		convai_speech_player.set_stream(convai_stream)
		convai_speech_player.play()
		stored_streamed_audio.resize(0)
		emit_signal("convAI_voice_sample_played")	

# Receiver function for when speech player finishes
func _on_speech_player_finished():
	# If not using streamed audio endpoint, then stored_streamed_audio will always be zero, if using streaming, then will be over 0 if being queued while player is already playing
	if stored_streamed_audio.size() > 0:
		convai_stream.data = stored_streamed_audio
		convai_speech_player.set_stream(convai_stream)
		convai_speech_player.play()
		stored_streamed_audio.resize(0)
		emit_signal("convAI_voice_sample_played")
	
func _on_sessionID_received(new_sessionID : String):
	set_session_id(new_sessionID)
	
func _on_tag_received(new_tag : String):
	# Doesn't appear to be much use now, but leaving here for future use
	pass

func _on_action_received(new_action):
	# Insert code to parse newlines, separate out if multiple actions
	pass

# Setter function for character
func set_character_id(new_character_id : String):
	convai_character_id = new_character_id
	
# Setter function for session
func set_session_id(new_session_id : String):
	convai_session_id = new_session_id

# Getter function for session
func get_session_id():
	return convai_session_id

# Setter function for API Key
func set_api_key(new_api_key : String):
	api_key = new_api_key

# Reset session ID so conversation is not remembered
func reset_session():
	convai_session_id = "-1"
	
# Determine if AI-generated response content also includes and uses voice file
func set_voice_response_mode(mode : bool):
	voice_response = mode
	
